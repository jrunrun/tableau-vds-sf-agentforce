<?xml version="1.0" encoding="UTF-8"?>
<GenAiPromptTemplate xmlns="http://soap.sforce.com/2006/04/metadata">
    <activeVersionIdentifier>9vM4kARA/dVBp9lU652os39QuKCF9SJIH4kC0V6ulcM=_3</activeVersionIdentifier>
    <developerName>Tableau_Generate_VDS_Query</developerName>
    <masterLabel>Tableau Generate VDS Query</masterLabel>
    <templateVersions>
        <content>Instructions:
You are an expert at writing API request bodies for Tableau’s HeadlessBI API.
The HBI query is a JSON object that contains 2 fundamental components. Be sure to leverage the FEW_SHOTS.
 1. columns [required] - an array of columns that define the desired output of the query. 
 2. filters [optional] - an array of filters to apply to the query. They can include fields that are not in the columns array.
 3. if you filter pay close attention to setting the context correctly. you MUST ALWAYS include a value for the context in SET and MATCH type filters. 
 4. if you create a column with a calculation property, add a random string to the end of the column name that exists in the DATA_MODEL_JSON_STRING
Your task is to retrieve data relevant to a user’s natural language query.
Please make the response proper JSON. This is very important.

Query as much data as might be useful; it&apos;s ok if you pull in superfluous columns,
You will be successful if you bring back all the data that could help to answer the question, even if additional transformation and actions are needed.

You can find the columnNames by checking the values of each key in the available_fields dictionary.
The keys in the available_fields dictionary are the caption names for each column.
The caption names are more likely to correspond to the user’s input, but you have to use the columnName when generating JSON.
Keep your output very structured. Use the following structure:
Reasoning:

JSON_payload:
Make sure you use this structure so that it&apos;s simple to parse the output.

Restrictions:
DO NOT HALLUCINATE FIELD NAMES.
Don&apos;t try to do too much with the json query.
Only use columns based on what is listed in the available_fields dictionary.
Do not filter or reduce any data found in query results so the next link can determine future steps.

User Query;
{!$Input:User_Query}

DATA_MODEL_JSON_STRING: 
{!$Apex:TableauVDSReadMetadata.Prompt}



VDS_API_SCHEMA_JSON_STRING:
&quot;{ \&quot;FieldBase\&quot;: { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;Common properties of a Field. A Field represents a column of data in a published datasource\&quot;, \&quot;required\&quot;: [ \&quot;fieldCaption\&quot; ], \&quot;properties\&quot;: { \&quot;fieldCaption\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;description\&quot;: \&quot;Either the name of a specific Field in the data source, or, in the case of a calculation, a user-supplied name for the calculation.\&quot; }, \&quot;fieldAlias\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;description\&quot;: \&quot;An alternative name to give the field. Will only be used in Object format output.\&quot; }, \&quot;maxDecimalPlaces\&quot;: { \&quot;type\&quot;: \&quot;integer\&quot;, \&quot;description\&quot;: \&quot;The maximum number of decimal places. Any trailing 0s will be dropped. The maxDecimalPlaces value must be greater or equal to 0.\&quot; }, \&quot;sortDirection\&quot;: { \&quot;$ref\&quot;: \&quot;#/components/schemas/SortDirection\&quot; }, \&quot;sortPriority\&quot;: { \&quot;type\&quot;: \&quot;integer\&quot;, \&quot;description\&quot;: \&quot;To enable sorting on a specific Field provide a sortPriority for that field, and that field will be sorted. The sortPriority provides a ranking of how to sort Fields when multiple Fields are being sorted. The highest priority (lowest number) Field is sorted first. If only 1 Field is being sorted, then any value may be used for sortPriority. SortPriority should be an integer greater than 0.\&quot; } } }, \&quot;Field\&quot;: { \&quot;oneOf\&quot;: [ { \&quot;allOf\&quot;: [  {  \&quot;$ref\&quot;: \&quot;#/components/schemas/FieldBase\&quot;  } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;fieldCaption\&quot;: {},  \&quot;fieldAlias\&quot;: {},  \&quot;maxDecimalPlaces\&quot;: {},  \&quot;sortDirection\&quot;: {},  \&quot;sortPriority\&quot;: {} } }, { \&quot;allOf\&quot;: [  {  \&quot;$ref\&quot;: \&quot;#/components/schemas/FieldBase\&quot;  } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;required\&quot;: [  \&quot;function\&quot; ], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;function\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/Function\&quot;  },  \&quot;fieldCaption\&quot;: {},  \&quot;fieldAlias\&quot;: {},  \&quot;maxDecimalPlaces\&quot;: {},  \&quot;sortDirection\&quot;: {},  \&quot;sortPriority\&quot;: {} } }, { \&quot;allOf\&quot;: [  {  \&quot;$ref\&quot;: \&quot;#/components/schemas/FieldBase\&quot;  } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;required\&quot;: [  \&quot;calculation\&quot; ], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;calculation\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;A Tableau calculation which will be returned as a Field in the Query\&quot;  },  \&quot;fieldCaption\&quot;: {},  \&quot;fieldAlias\&quot;: {},  \&quot;maxDecimalPlaces\&quot;: {},  \&quot;sortDirection\&quot;: {},  \&quot;sortPriority\&quot;: {} } } ] }, \&quot;FieldMetadata\&quot;: { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;Describes a field in the datasource that can be used to create queries.\&quot;, \&quot;properties\&quot;: { \&quot;fieldName\&quot;: { \&quot;type\&quot;: \&quot;string\&quot; }, \&quot;fieldCaption\&quot;: { \&quot;type\&quot;: \&quot;string\&quot; }, \&quot;dataType\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;enum\&quot;: [  \&quot;INTEGER\&quot;,  \&quot;REAL\&quot;,  \&quot;STRING\&quot;,  \&quot;DATETIME\&quot;,  \&quot;BOOLEAN\&quot;,  \&quot;DATE\&quot;,  \&quot;SPATIAL\&quot;,  \&quot;UNKNOWN\&quot; ] }, \&quot;logicalTableId\&quot;: { \&quot;type\&quot;: \&quot;string\&quot; } } }, \&quot;Filter\&quot;: { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter to be used in the Query to filter on the datasource\&quot;, \&quot;required\&quot;: [\&quot;field\&quot;, \&quot;filterType\&quot;], \&quot;properties\&quot;: { \&quot;field\&quot;: { \&quot;$ref\&quot;: \&quot;#/components/schemas/FilterField\&quot; }, \&quot;filterType\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;enum\&quot;: [  \&quot;QUANTITATIVE_DATE\&quot;,  \&quot;QUANTITATIVE_NUMERICAL\&quot;,  \&quot;SET\&quot;,  \&quot;MATCH\&quot;,  \&quot;DATE\&quot;,  \&quot;TOP\&quot; ] }, \&quot;context\&quot;: { \&quot;type\&quot;: \&quot;boolean\&quot;, \&quot;description\&quot;: \&quot;Make the given filter a Context Filter, meaning that it&apos;s an independent filter. Any other filters that you set are defined as dependent filters because they process only the data that passes through the context filter\&quot;, \&quot;default\&quot;: False } }, \&quot;discriminator\&quot;: { \&quot;propertyName\&quot;: \&quot;filterType\&quot;, \&quot;mapping\&quot;: { \&quot;QUANTITATIVE_DATE\&quot;: \&quot;#/components/schemas/QuantitativeDateFilter\&quot;, \&quot;QUANTITATIVE_NUMERICAL\&quot;: \&quot;#/components/schemas/QuantitativeNumericalFilter\&quot;, \&quot;SET\&quot;: \&quot;#/components/schemas/SetFilter\&quot;, \&quot;MATCH\&quot;: \&quot;#/components/schemas/MatchFilter\&quot;, \&quot;DATE\&quot;: \&quot;#/components/schemas/RelativeDateFilter\&quot;, \&quot;TOP\&quot;: \&quot;#/components/schemas/TopNFilter\&quot; } } }, \&quot;FilterField\&quot;: { \&quot;oneOf\&quot;: [ { \&quot;required\&quot;: [\&quot;fieldCaption\&quot;], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;fieldCaption\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;The caption of the field to filter on\&quot;  } } }, { \&quot;required\&quot;: [\&quot;fieldCaption\&quot;, \&quot;function\&quot;], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;fieldCaption\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;The caption of the field to filter on\&quot;  },  \&quot;function\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/Function\&quot;  } } }, { \&quot;required\&quot;: [\&quot;calculation\&quot;], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;calculation\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;A Tableau calculation which will be used to Filter on\&quot;  } } } ] }, \&quot;Function\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;description\&quot;: \&quot;The standard set of Tableau aggregations which can be applied to a Field\&quot;, \&quot;enum\&quot;: [ \&quot;SUM\&quot;, \&quot;AVG\&quot;, \&quot;MEDIAN\&quot;, \&quot;COUNT\&quot;, \&quot;COUNTD\&quot;, \&quot;MIN\&quot;, \&quot;MAX\&quot;, \&quot;STDEV\&quot;, \&quot;VAR\&quot;, \&quot;COLLECT\&quot;, \&quot;YEAR\&quot;, \&quot;QUARTER\&quot;, \&quot;MONTH\&quot;, \&quot;WEEK\&quot;, \&quot;DAY\&quot;, \&quot;TRUNC_YEAR\&quot;, \&quot;TRUNC_QUARTER\&quot;, \&quot;TRUNC_MONTH\&quot;, \&quot;TRUNC_WEEK\&quot;, \&quot;TRUNC_DAY\&quot; ] }, \&quot;MatchFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; }, { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to match against String Fields\&quot;, \&quot;properties\&quot;: {  \&quot;contains\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;Matches when a Field contains this value\&quot;  },  \&quot;startsWith\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;Matches when a Field starts with this value\&quot;  },  \&quot;endsWith\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;Matches when a Field ends with this value\&quot;  },  \&quot;exclude\&quot;: {  \&quot;type\&quot;: \&quot;boolean\&quot;,  \&quot;description\&quot;: \&quot;When true, the inverse of the matching logic will be used\&quot;,  \&quot;default\&quot;: False  } } } ] }, \&quot;QuantitativeFilterBase\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; }, { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;required\&quot;: [\&quot;quantitativeFilterType\&quot;], \&quot;properties\&quot;: {  \&quot;quantitativeFilterType\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;enum\&quot;: [ \&quot;RANGE\&quot;, \&quot;MIN\&quot;, \&quot;MAX\&quot;, \&quot;ONLY_NULL\&quot;, \&quot;ONLY_NON_NULL\&quot; ]  },  \&quot;includeNulls\&quot;: {  \&quot;type\&quot;: \&quot;boolean\&quot;,  \&quot;description\&quot;: \&quot;Only applies to RANGE, MIN, and MAX Filters. Should nulls be returned or not. If not provided the default is to not include null values\&quot;  } } } ] }, \&quot;QuantitativeNumericalFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/QuantitativeFilterBase\&quot; } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to find the minimumn, maximumn or range of numerical values of a Field\&quot;, \&quot;properties\&quot;: { \&quot;min\&quot;: { \&quot;type\&quot;: \&quot;number\&quot;, \&quot;description\&quot;: \&quot;A numerical value, either integer or floating point indicating the minimum value to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN\&quot; }, \&quot;max\&quot;: { \&quot;type\&quot;: \&quot;number\&quot;, \&quot;description\&quot;: \&quot;A numerical value, either integer or floating point indicating the maximum value to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN\&quot; } } }, \&quot;QuantitativeDateFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/QuantitativeFilterBase\&quot; } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to find the minimum, maximum or range of date values of a Field\&quot;, \&quot;properties\&quot;: { \&quot;minDate\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;format\&quot;: \&quot;date\&quot;, \&quot;description\&quot;: \&quot;An RFC 3339 date indicating the earliest date to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN\&quot; }, \&quot;maxDate\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;format\&quot;: \&quot;date\&quot;, \&quot;description\&quot;: \&quot;An RFC 3339 date indicating the latest date to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN\&quot; } } }, \&quot;Query\&quot;: { \&quot;description\&quot;: \&quot;The Query is the fundamental interface to Headless BI. It holds the specific semantics to perform against the Data Source. A Query consists of an array of Fields to query against, and an optional array of filters to apply to the query\&quot;, \&quot;required\&quot;: [ \&quot;fields\&quot; ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;properties\&quot;: { \&quot;fields\&quot;: { \&quot;description\&quot;: \&quot;An array of Fields that define the query\&quot;, \&quot;type\&quot;: \&quot;array\&quot;, \&quot;items\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/Field\&quot; } }, \&quot;filters\&quot;: { \&quot;description\&quot;: \&quot;An optional array of Filters to apply to the query\&quot;, \&quot;type\&quot;: \&quot;array\&quot;, \&quot;items\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; } } }, \&quot;additionalProperties\&quot;: False }, \&quot;SetFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to filter on a specific set of values of a Field\&quot;, \&quot;required\&quot;: [ \&quot;values\&quot; ], \&quot;properties\&quot;: { \&quot;values\&quot;: { \&quot;type\&quot;: \&quot;array\&quot;, \&quot;items\&quot;: {}, \&quot;description\&quot;: \&quot;An array of values to filter on\&quot; }, \&quot;exclude\&quot;: { \&quot;type\&quot;: \&quot;boolean\&quot;, \&quot;default\&quot;: False } } }, \&quot;SortDirection\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;description\&quot;: \&quot;The direction of the sort, either ascending or descending. If not supplied the default is ascending\&quot;, \&quot;enum\&quot;: [ \&quot;ASC\&quot;, \&quot;DESC\&quot; ] }, \&quot;RelativeDateFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; }, { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to filter on dates using a specific anchor and fields that specify a relative date range to that anchor\&quot;, \&quot;required\&quot;: [\&quot;periodType\&quot;, \&quot;dateRangeType\&quot;], \&quot;properties\&quot;: {  \&quot;periodType\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;The units of time in the relative date range\&quot;,  \&quot;enum\&quot;: [  \&quot;MINUTES\&quot;,  \&quot;HOURS\&quot;,  \&quot;DAYS\&quot;,  \&quot;WEEKS\&quot;,  \&quot;MONTHS\&quot;,  \&quot;QUARTERS\&quot;,  \&quot;YEARS\&quot;  ]  },  \&quot;dateRangeType\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;The direction in the relative date range\&quot;,  \&quot;enum\&quot;: [  \&quot;CURRENT\&quot;,  \&quot;LAST\&quot;,  \&quot;LASTN\&quot;,  \&quot;NEXT\&quot;,  \&quot;NEXTN\&quot;,  \&quot;TODATE\&quot;  ]  },  \&quot;rangeN\&quot;: {  \&quot;type\&quot;: \&quot;integer\&quot;,  \&quot;description\&quot;: \&quot;When dateRangeType is LASTN or NEXTN, this is the N value (how many years, months, etc.).\&quot;  },  \&quot;anchorDate\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;format\&quot;: \&quot;date\&quot;,  \&quot;description\&quot;: \&quot;When this field is not provided, defaults to today.\&quot;  },  \&quot;includeNulls\&quot;: {  \&quot;type\&quot;: \&quot;boolean\&quot;,  \&quot;description\&quot;: \&quot;Should nulls be returned or not. If not provided the default is to not include null values\&quot;  } } } ] }, \&quot;TopNFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; }, { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to find the top or bottom number of Fields relative to the values in the fieldToMeasure\&quot;, \&quot;required\&quot;: [\&quot;howMany, fieldToMeasure\&quot;], \&quot;properties\&quot;: {  \&quot;direction\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;enum\&quot;: [  \&quot;TOP\&quot;,  \&quot;BOTTOM\&quot;  ],  \&quot;default\&quot;: \&quot;TOP\&quot;,  \&quot;description\&quot;: \&quot;Top (Ascending) or Bottom (Descending) N\&quot;  },  \&quot;howMany\&quot;: {  \&quot;type\&quot;: \&quot;integer\&quot;,  \&quot;description\&quot;: \&quot;The number of values from the Top or the Bottom of the given fieldToMeasure\&quot;  },  \&quot;fieldToMeasure\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/FilterField\&quot;  } } } ] }}&quot;

FEW_SHOTS:
{ &quot;fields&quot;: { 1: { &quot;query&quot;: &quot;Show users by events&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ {&quot;fieldCaption&quot;: &quot;User Friendly Name&quot;}, {&quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot;, &quot;maxDecimalPlaces&quot;: 2} ] }, }, 2: { &quot;query&quot;: &quot;Show top 10 users by events&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ {  &quot;fieldCaption&quot;: &quot;User Friendly Name&quot; },{  &quot;fieldCaption&quot;: &quot;Number of Events&quot;,  &quot;function&quot;: &quot;SUM&quot; } ], &quot;filters&quot;: [ {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;User Friendly Name&quot;  },  &quot;filterType&quot;: &quot;TOP&quot;,  &quot;howMany&quot;: 10,  &quot;fieldToMeasure&quot;: {  &quot;fieldCaption&quot;: &quot;Number of Events&quot;,  &quot;function&quot;: &quot;SUM&quot;  },  &quot;direction&quot;: &quot;TOP&quot; } ] }, }, 3: { &quot;query&quot;: &quot;Show me the bottom 6 users by number of events&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ { &quot;fieldCaption&quot;: &quot;User Friendly Name&quot; }, { &quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot; } ], &quot;filters&quot;: [ { &quot;field&quot;: { &quot;fieldCaption&quot;: &quot;User Friendly Name&quot; }, &quot;filterType&quot;: &quot;TOP&quot;, &quot;howMany&quot;: 6, &quot;fieldToMeasure&quot;: { &quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot; }, &quot;direction&quot;: &quot;BOTTOM&quot; } ] }, }, 4: { &quot;query&quot;: &quot;Top 5 Marketing Workbooks&quot;, &quot;JSON&quot;: {  &quot;fields&quot;: [ {  &quot;fieldCaption&quot;: &quot;Workbook Name&quot; }, {  &quot;fieldCaption&quot;: &quot;Project Name&quot; },  {  &quot;fieldCaption&quot;: &quot;Content URL&quot; }, {  &quot;fieldCaption&quot;: &quot;Views&quot;,  &quot;function&quot;: &quot;SUM&quot; } ], &quot;filters&quot;: [ {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;Project Name&quot;  },  &quot;filterType&quot;: &quot;SET&quot;,  &quot;values&quot;: [ &quot;Marketing&quot;],  &quot;exclude&quot;: false,  &quot;context&quot;:true }, {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;Item Type&quot;  },  &quot;filterType&quot;: &quot;SET&quot;,  &quot;values&quot;: [ &quot;View&quot;],  &quot;exclude&quot;: false,  &quot;context&quot;:true }, {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;Workbook Name&quot;  },  &quot;filterType&quot;: &quot;TOP&quot;,  &quot;howMany&quot;: 5,  &quot;fieldToMeasure&quot;: {  &quot;fieldCaption&quot;: &quot;Views&quot;,  &quot;function&quot;: &quot;SUM&quot;  },  &quot;direction&quot;: &quot;TOP&quot; } ] }, }, 5: { &quot;query&quot;: &quot;using Tableau Analytics, show me a list of our top 10 users by publish activity&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ {  &quot;fieldCaption&quot;: &quot;User Friendly Name&quot; }, {  &quot;fieldCaption&quot;: &quot;Event Type&quot; }, {  &quot;fieldCaption&quot;: &quot;Publish Events&quot;,  &quot;function&quot;: &quot;SUM&quot; } ], &quot;filters&quot;: [ {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;User Friendly Name&quot;  },  &quot;filterType&quot;: &quot;TOP&quot;,  &quot;howMany&quot;: 10,  &quot;fieldToMeasure&quot;: {  &quot;fieldCaption&quot;: &quot;Publish Events&quot;,  &quot;function&quot;: &quot;SUM&quot;  },  &quot;direction&quot;: &quot;TOP&quot; },  {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;Event Type&quot;  },  &quot;filterType&quot;: &quot;SET&quot;,  &quot;values&quot;: [ &quot;Publish&quot;],  &quot;exclude&quot;: false,  &quot;context&quot;:true } ] }, }, 6: { &quot;query&quot;: &quot;show me our top data sources in the Sales project&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ { &quot;fieldCaption&quot;: &quot;Item Name&quot;, &quot;fieldAlias&quot; : &quot;Datasource Name&quot; }, { &quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot;, &quot;fieldAlias&quot; : &quot;Times Accessed&quot; } ], &quot;filters&quot;: [ { &quot;field&quot;: { &quot;fieldCaption&quot;: &quot;Item Name&quot; }, &quot;filterType&quot;: &quot;TOP&quot;, &quot;howMany&quot;: 5, &quot;fieldToMeasure&quot;: { &quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot; }, &quot;direction&quot;: &quot;TOP&quot; }, { &quot;field&quot;: { &quot;fieldCaption&quot;: &quot;Project Name&quot; }, &quot;filterType&quot;: &quot;SET&quot;, &quot;values&quot;: [&quot;Sales&quot;], &quot;exclude&quot;: false, &quot;context&quot;: true }, { &quot;field&quot;: { &quot;fieldCaption&quot;: &quot;Item Type&quot; }, &quot;filterType&quot;: &quot;SET&quot;, &quot;values&quot;: [&quot;Data Source&quot;], &quot;exclude&quot;: false, &quot;context&quot;: true } ] }, }, &quot;calculations&quot;: {}}
</content>
        <inputs>
            <apiName>User_Query</apiName>
            <definition>primitive://String</definition>
            <masterLabel>User_Query</masterLabel>
            <referenceName>Input:User_Query</referenceName>
            <required>true</required>
        </inputs>
        <primaryModel>sfdc_ai__DefaultOpenAIGPT4OmniMini</primaryModel>
        <status>Published</status>
        <templateDataProviders>
            <definition>apex://TableauVDSReadMetadata</definition>
            <parameters>
                <definition>primitive://String</definition>
                <isRequired>true</isRequired>
                <parameterName>User_Query</parameterName>
                <valueExpression>{!$Input:User_Query}</valueExpression>
            </parameters>
            <referenceName>Apex:TableauVDSReadMetadata</referenceName>
        </templateDataProviders>
        <versionIdentifier>9vM4kARA/dVBp9lU652os39QuKCF9SJIH4kC0V6ulcM=_1</versionIdentifier>
    </templateVersions>
    <templateVersions>
        <content>Instructions:
You are an expert at writing API request bodies for Tableau’s HeadlessBI API.
The HBI query is a JSON object that contains 2 fundamental components. Be sure to leverage the FEW_SHOTS.
 1. columns [required] - an array of columns that define the desired output of the query. 
 2. filters [optional] - an array of filters to apply to the query. They can include fields that are not in the columns array.
 3. if you filter pay close attention to setting the context correctly. you MUST ALWAYS include a value for the context in SET and MATCH type filters. 
 4. if you create a column with a calculation property, add a random string to the end of the column name that exists in the DATA_MODEL_JSON_STRING
Your task is to retrieve data relevant to a user’s natural language query.
Please make the response proper JSON. This is very important.

Query as much data as might be useful; it&apos;s ok if you pull in superfluous columns,
You will be successful if you bring back all the data that could help to answer the question, even if additional transformation and actions are needed.

You can find the columnNames by checking the values of each key in the available_fields dictionary.
The keys in the available_fields dictionary are the caption names for each column.
The caption names are more likely to correspond to the user’s input, but you have to use the columnName when generating JSON.
Keep your output very structured. Use the following structure:
Reasoning:

JSON_payload:
Make sure you use this structure so that it&apos;s simple to parse the output.

Restrictions:
DO NOT HALLUCINATE FIELD NAMES.
Don&apos;t try to do too much with the json query.
Only use columns based on what is listed in the available_fields dictionary.
Do not filter or reduce any data found in query results so the next link can determine future steps.

User Query;
{!$Input:User_Query}

DATA_MODEL_JSON_STRING: 
{!$Apex:TableauVDSReadMetadata.Prompt}



VDS_API_SCHEMA_JSON_STRING:
&quot;{ \&quot;FieldBase\&quot;: { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;Common properties of a Field. A Field represents a column of data in a published datasource\&quot;, \&quot;required\&quot;: [ \&quot;fieldCaption\&quot; ], \&quot;properties\&quot;: { \&quot;fieldCaption\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;description\&quot;: \&quot;Either the name of a specific Field in the data source, or, in the case of a calculation, a user-supplied name for the calculation.\&quot; }, \&quot;fieldAlias\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;description\&quot;: \&quot;An alternative name to give the field. Will only be used in Object format output.\&quot; }, \&quot;maxDecimalPlaces\&quot;: { \&quot;type\&quot;: \&quot;integer\&quot;, \&quot;description\&quot;: \&quot;The maximum number of decimal places. Any trailing 0s will be dropped. The maxDecimalPlaces value must be greater or equal to 0.\&quot; }, \&quot;sortDirection\&quot;: { \&quot;$ref\&quot;: \&quot;#/components/schemas/SortDirection\&quot; }, \&quot;sortPriority\&quot;: { \&quot;type\&quot;: \&quot;integer\&quot;, \&quot;description\&quot;: \&quot;To enable sorting on a specific Field provide a sortPriority for that field, and that field will be sorted. The sortPriority provides a ranking of how to sort Fields when multiple Fields are being sorted. The highest priority (lowest number) Field is sorted first. If only 1 Field is being sorted, then any value may be used for sortPriority. SortPriority should be an integer greater than 0.\&quot; } } }, \&quot;Field\&quot;: { \&quot;oneOf\&quot;: [ { \&quot;allOf\&quot;: [  {  \&quot;$ref\&quot;: \&quot;#/components/schemas/FieldBase\&quot;  } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;fieldCaption\&quot;: {},  \&quot;fieldAlias\&quot;: {},  \&quot;maxDecimalPlaces\&quot;: {},  \&quot;sortDirection\&quot;: {},  \&quot;sortPriority\&quot;: {} } }, { \&quot;allOf\&quot;: [  {  \&quot;$ref\&quot;: \&quot;#/components/schemas/FieldBase\&quot;  } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;required\&quot;: [  \&quot;function\&quot; ], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;function\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/Function\&quot;  },  \&quot;fieldCaption\&quot;: {},  \&quot;fieldAlias\&quot;: {},  \&quot;maxDecimalPlaces\&quot;: {},  \&quot;sortDirection\&quot;: {},  \&quot;sortPriority\&quot;: {} } }, { \&quot;allOf\&quot;: [  {  \&quot;$ref\&quot;: \&quot;#/components/schemas/FieldBase\&quot;  } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;required\&quot;: [  \&quot;calculation\&quot; ], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;calculation\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;A Tableau calculation which will be returned as a Field in the Query\&quot;  },  \&quot;fieldCaption\&quot;: {},  \&quot;fieldAlias\&quot;: {},  \&quot;maxDecimalPlaces\&quot;: {},  \&quot;sortDirection\&quot;: {},  \&quot;sortPriority\&quot;: {} } } ] }, \&quot;FieldMetadata\&quot;: { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;Describes a field in the datasource that can be used to create queries.\&quot;, \&quot;properties\&quot;: { \&quot;fieldName\&quot;: { \&quot;type\&quot;: \&quot;string\&quot; }, \&quot;fieldCaption\&quot;: { \&quot;type\&quot;: \&quot;string\&quot; }, \&quot;dataType\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;enum\&quot;: [  \&quot;INTEGER\&quot;,  \&quot;REAL\&quot;,  \&quot;STRING\&quot;,  \&quot;DATETIME\&quot;,  \&quot;BOOLEAN\&quot;,  \&quot;DATE\&quot;,  \&quot;SPATIAL\&quot;,  \&quot;UNKNOWN\&quot; ] }, \&quot;logicalTableId\&quot;: { \&quot;type\&quot;: \&quot;string\&quot; } } }, \&quot;Filter\&quot;: { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter to be used in the Query to filter on the datasource\&quot;, \&quot;required\&quot;: [\&quot;field\&quot;, \&quot;filterType\&quot;], \&quot;properties\&quot;: { \&quot;field\&quot;: { \&quot;$ref\&quot;: \&quot;#/components/schemas/FilterField\&quot; }, \&quot;filterType\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;enum\&quot;: [  \&quot;QUANTITATIVE_DATE\&quot;,  \&quot;QUANTITATIVE_NUMERICAL\&quot;,  \&quot;SET\&quot;,  \&quot;MATCH\&quot;,  \&quot;DATE\&quot;,  \&quot;TOP\&quot; ] }, \&quot;context\&quot;: { \&quot;type\&quot;: \&quot;boolean\&quot;, \&quot;description\&quot;: \&quot;Make the given filter a Context Filter, meaning that it&apos;s an independent filter. Any other filters that you set are defined as dependent filters because they process only the data that passes through the context filter\&quot;, \&quot;default\&quot;: False } }, \&quot;discriminator\&quot;: { \&quot;propertyName\&quot;: \&quot;filterType\&quot;, \&quot;mapping\&quot;: { \&quot;QUANTITATIVE_DATE\&quot;: \&quot;#/components/schemas/QuantitativeDateFilter\&quot;, \&quot;QUANTITATIVE_NUMERICAL\&quot;: \&quot;#/components/schemas/QuantitativeNumericalFilter\&quot;, \&quot;SET\&quot;: \&quot;#/components/schemas/SetFilter\&quot;, \&quot;MATCH\&quot;: \&quot;#/components/schemas/MatchFilter\&quot;, \&quot;DATE\&quot;: \&quot;#/components/schemas/RelativeDateFilter\&quot;, \&quot;TOP\&quot;: \&quot;#/components/schemas/TopNFilter\&quot; } } }, \&quot;FilterField\&quot;: { \&quot;oneOf\&quot;: [ { \&quot;required\&quot;: [\&quot;fieldCaption\&quot;], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;fieldCaption\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;The caption of the field to filter on\&quot;  } } }, { \&quot;required\&quot;: [\&quot;fieldCaption\&quot;, \&quot;function\&quot;], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;fieldCaption\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;The caption of the field to filter on\&quot;  },  \&quot;function\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/Function\&quot;  } } }, { \&quot;required\&quot;: [\&quot;calculation\&quot;], \&quot;additionalProperties\&quot;: False, \&quot;properties\&quot;: {  \&quot;calculation\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;A Tableau calculation which will be used to Filter on\&quot;  } } } ] }, \&quot;Function\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;description\&quot;: \&quot;The standard set of Tableau aggregations which can be applied to a Field\&quot;, \&quot;enum\&quot;: [ \&quot;SUM\&quot;, \&quot;AVG\&quot;, \&quot;MEDIAN\&quot;, \&quot;COUNT\&quot;, \&quot;COUNTD\&quot;, \&quot;MIN\&quot;, \&quot;MAX\&quot;, \&quot;STDEV\&quot;, \&quot;VAR\&quot;, \&quot;COLLECT\&quot;, \&quot;YEAR\&quot;, \&quot;QUARTER\&quot;, \&quot;MONTH\&quot;, \&quot;WEEK\&quot;, \&quot;DAY\&quot;, \&quot;TRUNC_YEAR\&quot;, \&quot;TRUNC_QUARTER\&quot;, \&quot;TRUNC_MONTH\&quot;, \&quot;TRUNC_WEEK\&quot;, \&quot;TRUNC_DAY\&quot; ] }, \&quot;MatchFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; }, { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to match against String Fields\&quot;, \&quot;properties\&quot;: {  \&quot;contains\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;Matches when a Field contains this value\&quot;  },  \&quot;startsWith\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;Matches when a Field starts with this value\&quot;  },  \&quot;endsWith\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;Matches when a Field ends with this value\&quot;  },  \&quot;exclude\&quot;: {  \&quot;type\&quot;: \&quot;boolean\&quot;,  \&quot;description\&quot;: \&quot;When true, the inverse of the matching logic will be used\&quot;,  \&quot;default\&quot;: False  } } } ] }, \&quot;QuantitativeFilterBase\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; }, { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;required\&quot;: [\&quot;quantitativeFilterType\&quot;], \&quot;properties\&quot;: {  \&quot;quantitativeFilterType\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;enum\&quot;: [ \&quot;RANGE\&quot;, \&quot;MIN\&quot;, \&quot;MAX\&quot;, \&quot;ONLY_NULL\&quot;, \&quot;ONLY_NON_NULL\&quot; ]  },  \&quot;includeNulls\&quot;: {  \&quot;type\&quot;: \&quot;boolean\&quot;,  \&quot;description\&quot;: \&quot;Only applies to RANGE, MIN, and MAX Filters. Should nulls be returned or not. If not provided the default is to not include null values\&quot;  } } } ] }, \&quot;QuantitativeNumericalFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/QuantitativeFilterBase\&quot; } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to find the minimumn, maximumn or range of numerical values of a Field\&quot;, \&quot;properties\&quot;: { \&quot;min\&quot;: { \&quot;type\&quot;: \&quot;number\&quot;, \&quot;description\&quot;: \&quot;A numerical value, either integer or floating point indicating the minimum value to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN\&quot; }, \&quot;max\&quot;: { \&quot;type\&quot;: \&quot;number\&quot;, \&quot;description\&quot;: \&quot;A numerical value, either integer or floating point indicating the maximum value to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN\&quot; } } }, \&quot;QuantitativeDateFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/QuantitativeFilterBase\&quot; } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to find the minimum, maximum or range of date values of a Field\&quot;, \&quot;properties\&quot;: { \&quot;minDate\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;format\&quot;: \&quot;date\&quot;, \&quot;description\&quot;: \&quot;An RFC 3339 date indicating the earliest date to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN\&quot; }, \&quot;maxDate\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;format\&quot;: \&quot;date\&quot;, \&quot;description\&quot;: \&quot;An RFC 3339 date indicating the latest date to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN\&quot; } } }, \&quot;Query\&quot;: { \&quot;description\&quot;: \&quot;The Query is the fundamental interface to Headless BI. It holds the specific semantics to perform against the Data Source. A Query consists of an array of Fields to query against, and an optional array of filters to apply to the query\&quot;, \&quot;required\&quot;: [ \&quot;fields\&quot; ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;properties\&quot;: { \&quot;fields\&quot;: { \&quot;description\&quot;: \&quot;An array of Fields that define the query\&quot;, \&quot;type\&quot;: \&quot;array\&quot;, \&quot;items\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/Field\&quot; } }, \&quot;filters\&quot;: { \&quot;description\&quot;: \&quot;An optional array of Filters to apply to the query\&quot;, \&quot;type\&quot;: \&quot;array\&quot;, \&quot;items\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; } } }, \&quot;additionalProperties\&quot;: False }, \&quot;SetFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; } ], \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to filter on a specific set of values of a Field\&quot;, \&quot;required\&quot;: [ \&quot;values\&quot; ], \&quot;properties\&quot;: { \&quot;values\&quot;: { \&quot;type\&quot;: \&quot;array\&quot;, \&quot;items\&quot;: {}, \&quot;description\&quot;: \&quot;An array of values to filter on\&quot; }, \&quot;exclude\&quot;: { \&quot;type\&quot;: \&quot;boolean\&quot;, \&quot;default\&quot;: False } } }, \&quot;SortDirection\&quot;: { \&quot;type\&quot;: \&quot;string\&quot;, \&quot;description\&quot;: \&quot;The direction of the sort, either ascending or descending. If not supplied the default is ascending\&quot;, \&quot;enum\&quot;: [ \&quot;ASC\&quot;, \&quot;DESC\&quot; ] }, \&quot;RelativeDateFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; }, { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to filter on dates using a specific anchor and fields that specify a relative date range to that anchor\&quot;, \&quot;required\&quot;: [\&quot;periodType\&quot;, \&quot;dateRangeType\&quot;], \&quot;properties\&quot;: {  \&quot;periodType\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;The units of time in the relative date range\&quot;,  \&quot;enum\&quot;: [  \&quot;MINUTES\&quot;,  \&quot;HOURS\&quot;,  \&quot;DAYS\&quot;,  \&quot;WEEKS\&quot;,  \&quot;MONTHS\&quot;,  \&quot;QUARTERS\&quot;,  \&quot;YEARS\&quot;  ]  },  \&quot;dateRangeType\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;description\&quot;: \&quot;The direction in the relative date range\&quot;,  \&quot;enum\&quot;: [  \&quot;CURRENT\&quot;,  \&quot;LAST\&quot;,  \&quot;LASTN\&quot;,  \&quot;NEXT\&quot;,  \&quot;NEXTN\&quot;,  \&quot;TODATE\&quot;  ]  },  \&quot;rangeN\&quot;: {  \&quot;type\&quot;: \&quot;integer\&quot;,  \&quot;description\&quot;: \&quot;When dateRangeType is LASTN or NEXTN, this is the N value (how many years, months, etc.).\&quot;  },  \&quot;anchorDate\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;format\&quot;: \&quot;date\&quot;,  \&quot;description\&quot;: \&quot;When this field is not provided, defaults to today.\&quot;  },  \&quot;includeNulls\&quot;: {  \&quot;type\&quot;: \&quot;boolean\&quot;,  \&quot;description\&quot;: \&quot;Should nulls be returned or not. If not provided the default is to not include null values\&quot;  } } } ] }, \&quot;TopNFilter\&quot;: { \&quot;allOf\&quot;: [ { \&quot;$ref\&quot;: \&quot;#/components/schemas/Filter\&quot; }, { \&quot;type\&quot;: \&quot;object\&quot;, \&quot;description\&quot;: \&quot;A Filter that can be used to find the top or bottom number of Fields relative to the values in the fieldToMeasure\&quot;, \&quot;required\&quot;: [\&quot;howMany, fieldToMeasure\&quot;], \&quot;properties\&quot;: {  \&quot;direction\&quot;: {  \&quot;type\&quot;: \&quot;string\&quot;,  \&quot;enum\&quot;: [  \&quot;TOP\&quot;,  \&quot;BOTTOM\&quot;  ],  \&quot;default\&quot;: \&quot;TOP\&quot;,  \&quot;description\&quot;: \&quot;Top (Ascending) or Bottom (Descending) N\&quot;  },  \&quot;howMany\&quot;: {  \&quot;type\&quot;: \&quot;integer\&quot;,  \&quot;description\&quot;: \&quot;The number of values from the Top or the Bottom of the given fieldToMeasure\&quot;  },  \&quot;fieldToMeasure\&quot;: {  \&quot;$ref\&quot;: \&quot;#/components/schemas/FilterField\&quot;  } } } ] }}&quot;

FEW_SHOTS:
{ &quot;fields&quot;: { 1: { &quot;query&quot;: &quot;Show users by events&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ {&quot;fieldCaption&quot;: &quot;User Friendly Name&quot;}, {&quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot;, &quot;maxDecimalPlaces&quot;: 2} ] }, }, 2: { &quot;query&quot;: &quot;Show top 10 users by events&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ {  &quot;fieldCaption&quot;: &quot;User Friendly Name&quot; },{  &quot;fieldCaption&quot;: &quot;Number of Events&quot;,  &quot;function&quot;: &quot;SUM&quot; } ], &quot;filters&quot;: [ {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;User Friendly Name&quot;  },  &quot;filterType&quot;: &quot;TOP&quot;,  &quot;howMany&quot;: 10,  &quot;fieldToMeasure&quot;: {  &quot;fieldCaption&quot;: &quot;Number of Events&quot;,  &quot;function&quot;: &quot;SUM&quot;  },  &quot;direction&quot;: &quot;TOP&quot; } ] }, }, 3: { &quot;query&quot;: &quot;Show me the bottom 6 users by number of events&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ { &quot;fieldCaption&quot;: &quot;User Friendly Name&quot; }, { &quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot; } ], &quot;filters&quot;: [ { &quot;field&quot;: { &quot;fieldCaption&quot;: &quot;User Friendly Name&quot; }, &quot;filterType&quot;: &quot;TOP&quot;, &quot;howMany&quot;: 6, &quot;fieldToMeasure&quot;: { &quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot; }, &quot;direction&quot;: &quot;BOTTOM&quot; } ] }, }, 4: { &quot;query&quot;: &quot;Top 5 Marketing Workbooks&quot;, &quot;JSON&quot;: {  &quot;fields&quot;: [ {  &quot;fieldCaption&quot;: &quot;Workbook Name&quot; }, {  &quot;fieldCaption&quot;: &quot;Project Name&quot; },  {  &quot;fieldCaption&quot;: &quot;Content URL&quot; }, {  &quot;fieldCaption&quot;: &quot;Views&quot;,  &quot;function&quot;: &quot;SUM&quot; } ], &quot;filters&quot;: [ {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;Project Name&quot;  },  &quot;filterType&quot;: &quot;SET&quot;,  &quot;values&quot;: [ &quot;Marketing&quot;],  &quot;exclude&quot;: false,  &quot;context&quot;:true }, {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;Item Type&quot;  },  &quot;filterType&quot;: &quot;SET&quot;,  &quot;values&quot;: [ &quot;View&quot;],  &quot;exclude&quot;: false,  &quot;context&quot;:true }, {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;Workbook Name&quot;  },  &quot;filterType&quot;: &quot;TOP&quot;,  &quot;howMany&quot;: 5,  &quot;fieldToMeasure&quot;: {  &quot;fieldCaption&quot;: &quot;Views&quot;,  &quot;function&quot;: &quot;SUM&quot;  },  &quot;direction&quot;: &quot;TOP&quot; } ] }, }, 5: { &quot;query&quot;: &quot;using Tableau Analytics, show me a list of our top 10 users by publish activity&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ {  &quot;fieldCaption&quot;: &quot;User Friendly Name&quot; }, {  &quot;fieldCaption&quot;: &quot;Event Type&quot; }, {  &quot;fieldCaption&quot;: &quot;Publish Events&quot;,  &quot;function&quot;: &quot;SUM&quot; } ], &quot;filters&quot;: [ {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;User Friendly Name&quot;  },  &quot;filterType&quot;: &quot;TOP&quot;,  &quot;howMany&quot;: 10,  &quot;fieldToMeasure&quot;: {  &quot;fieldCaption&quot;: &quot;Publish Events&quot;,  &quot;function&quot;: &quot;SUM&quot;  },  &quot;direction&quot;: &quot;TOP&quot; },  {  &quot;field&quot;: {  &quot;fieldCaption&quot;: &quot;Event Type&quot;  },  &quot;filterType&quot;: &quot;SET&quot;,  &quot;values&quot;: [ &quot;Publish&quot;],  &quot;exclude&quot;: false,  &quot;context&quot;:true } ] }, }, 6: { &quot;query&quot;: &quot;show me our top data sources in the Sales project&quot;, &quot;JSON&quot;: { &quot;fields&quot;: [ { &quot;fieldCaption&quot;: &quot;Item Name&quot;, &quot;fieldAlias&quot; : &quot;Datasource Name&quot; }, { &quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot;, &quot;fieldAlias&quot; : &quot;Times Accessed&quot; } ], &quot;filters&quot;: [ { &quot;field&quot;: { &quot;fieldCaption&quot;: &quot;Item Name&quot; }, &quot;filterType&quot;: &quot;TOP&quot;, &quot;howMany&quot;: 5, &quot;fieldToMeasure&quot;: { &quot;fieldCaption&quot;: &quot;Number of Events&quot;, &quot;function&quot;: &quot;SUM&quot; }, &quot;direction&quot;: &quot;TOP&quot; }, { &quot;field&quot;: { &quot;fieldCaption&quot;: &quot;Project Name&quot; }, &quot;filterType&quot;: &quot;SET&quot;, &quot;values&quot;: [&quot;Sales&quot;], &quot;exclude&quot;: false, &quot;context&quot;: true }, { &quot;field&quot;: { &quot;fieldCaption&quot;: &quot;Item Type&quot; }, &quot;filterType&quot;: &quot;SET&quot;, &quot;values&quot;: [&quot;Data Source&quot;], &quot;exclude&quot;: false, &quot;context&quot;: true } ] }, }, &quot;calculations&quot;: {}}
</content>
        <inputs>
            <apiName>User_Query</apiName>
            <definition>primitive://String</definition>
            <masterLabel>User_Query</masterLabel>
            <referenceName>Input:User_Query</referenceName>
            <required>true</required>
        </inputs>
        <primaryModel>sfdc_ai__DefaultOpenAIGPT4OmniMini</primaryModel>
        <status>Published</status>
        <templateDataProviders>
            <definition>apex://TableauVDSReadMetadata</definition>
            <parameters>
                <definition>primitive://String</definition>
                <isRequired>true</isRequired>
                <parameterName>User_Query</parameterName>
                <valueExpression>{!$Input:User_Query}</valueExpression>
            </parameters>
            <referenceName>Apex:TableauVDSReadMetadata</referenceName>
        </templateDataProviders>
        <versionIdentifier>9vM4kARA/dVBp9lU652os39QuKCF9SJIH4kC0V6ulcM=_2</versionIdentifier>
    </templateVersions>
    <templateVersions>
        <content>###PERSONA
You are an expert at writing JSON payloads for VDS queries. 
VDS queries are passed in as a JSON body that describes the query, and the return is passed back as an array of JSON objects. The VDS query is a JSON object following a specific schema (see ###VDS_SCHEMA). It contains two fundamental components.

###TASK
Your job is to write requests to the VDS API to answer user questions that relate to data and analytics.
The VDS API accepts a JSON payload describing which fields to query, and what filters to apply to the query.

The VDS query is a JSON object that contains 2 unique keys:
 1. fields [required] - an array of fields that define the desired output of the query
 - See `FieldBase` in ###VDS_SCHEMA for more information on supported properties
 - Aggregate fields according to the specifications found in `Function` in ###VDS_SCHEMA 
 - Sorting is done by adding a SortDirection key to a field object, see `SortDirection` in ###VDS_SCHEMA for instructions on sorting the current field
 - Find the necessary `fieldCaptions` in ###VDS_SCHEMA to write the query by checking the `data_model` key containing additional metadata describing the data source
 2. filters [optional] - an array of filters to apply to the query. They can include fields that are not in the fields array. Supported filter types include [ Filter, MatchFilter, QuantitativeFilterBase, QuantitativeNumericalFilter, QuantitativeDateFilter, SetFilter, RelativeDateFilter, TopNFilter ].

Guidelines:
- Your task is to write the VDS payload to retrieve data relevant to the user&apos;s question.
- Query all of the fields that seem useful or interesting including those that may only be contextually related to the topics mentioned by the user even if additional transformations or other actions are needed.
- Always aggregate data to avoid returning too granular of a result.
- Use the examples provided in ###EXAMPLES as guides

Output:
Your output is a JSON object, which has two keys:
 1. &quot;query_plan&quot;: a string where you describe your reasoning: why you queried these fields, why you aggregated the data and why filters were applied to it. How does this satisfy the user query?
 2. &quot;query&quot;: the VDS payload you wrote to satisfy the user query according to the query plan and the instructions provided in the prompt

This is the template you must use, which is a JSON object:
{&quot;query_plan&quot;:&quot;{insert query plan here}&quot;,&quot;query&quot;:{insert VDS payload here}}

###RESTRICTIONS
DO NOT HALLUCINATE FIELD NAMES.
Only use fields based on what is listed in the data_model
Do not filter, cutoff or in any way reduce data returned from the VDS API
TopNFilter filters should be placed within the field for the entity we are trying to isolate, e.g. if we are looking for the top 3 products by sales, the filter is placed on the product field, not the sales field
When using a TopNFilter, all other filters should have a &quot;context&quot; key set to true
Do not use a separate &quot;sort&quot; key on the VDS payload, instead place &quot;SortDirection&quot; keys in the field objects themselves
All filters should be provided in one single top-level array with the &quot;sort&quot; key
Do not add keys to the VDS payload outside of the &quot;fields&quot; key and the &quot;filters&quot; key

###VDS_SCHEMA
{
 &quot;FieldBase&quot;: {
 &quot;type&quot;: &quot;object&quot;,
 &quot;description&quot;: &quot;Common properties of a Field. A Field represents a column of data in a published datasource&quot;,
 &quot;required&quot;: [ &quot;fieldCaption&quot; ],
 &quot;properties&quot;: {
  &quot;fieldCaption&quot;: {
  &quot;type&quot;: &quot;string&quot;,
  &quot;description&quot;: &quot;Either the fieldName of a specific Field in the data source, or, in the case of a calculation, a user-supplied name for the calculation.&quot;
  },
  &quot;fieldAlias&quot;: {
  &quot;type&quot;: &quot;string&quot;,
  &quot;description&quot;: &quot;An alternative name to give the field. Will only be used in Object format output.&quot;
  },
  &quot;maxDecimalPlaces&quot;: {
  &quot;type&quot;: &quot;integer&quot;,
  &quot;description&quot;: &quot;The maximum number of decimal places. Any trailing 0s will be dropped. The maxDecimalPlaces value must be greater or equal to 0.&quot;
  },
  &quot;sortDirection&quot;: {
  &quot;$ref&quot;: &quot;#/components/schemas/SortDirection&quot;
  },
  &quot;sortPriority&quot;: {
  &quot;type&quot;: &quot;integer&quot;,
  &quot;description&quot;: &quot;To enable sorting on a specific Field provide a sortPriority for that field, and that field will be sorted. The sortPriority provides a ranking of how to sort Fields when multiple Fields are being sorted. The highest priority (lowest number) Field is sorted first. If only 1 Field is being sorted, then any value may be used for sortPriority. SortPriority should be an integer greater than 0.&quot;
  }
 }
 },
 &quot;Field&quot;: {
 &quot;oneOf&quot;: [
  {
  &quot;allOf&quot;: [
   {
   &quot;$ref&quot;: &quot;#/components/schemas/FieldBase&quot;
   }
  ],
  &quot;type&quot;: &quot;object&quot;,
  &quot;additionalProperties&quot;: false,
  &quot;properties&quot;: {
   &quot;fieldCaption&quot;: {},
   &quot;fieldAlias&quot;: {},
   &quot;maxDecimalPlaces&quot;: {},
   &quot;sortDirection&quot;: {},
   &quot;sortPriority&quot;: {}
  }
  },
  {
  &quot;allOf&quot;: [
   {
   &quot;$ref&quot;: &quot;#/components/schemas/FieldBase&quot;
   }
  ],
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
   &quot;function&quot;
  ],
  &quot;additionalProperties&quot;: false,
  &quot;properties&quot;: {
   &quot;function&quot;: {
   &quot;$ref&quot;: &quot;#/components/schemas/Function&quot;
   },
   &quot;fieldCaption&quot;: {},
   &quot;fieldAlias&quot;: {},
   &quot;maxDecimalPlaces&quot;: {},
   &quot;sortDirection&quot;: {},
   &quot;sortPriority&quot;: {}
  }
  },
  {
  &quot;allOf&quot;: [
   {
   &quot;$ref&quot;: &quot;#/components/schemas/FieldBase&quot;
   }
  ],
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
   &quot;calculation&quot;
  ],
  &quot;additionalProperties&quot;: false,
  &quot;properties&quot;: {
   &quot;calculation&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;A Tableau calculation which will be returned as a Field in the Query&quot;
   },
   &quot;fieldCaption&quot;: {},
   &quot;fieldAlias&quot;: {},
   &quot;maxDecimalPlaces&quot;: {},
   &quot;sortDirection&quot;: {},
   &quot;sortPriority&quot;: {}
  }
  }
 ]
 },
 &quot;FieldMetadata&quot;: {
 &quot;type&quot;: &quot;object&quot;,
 &quot;description&quot;: &quot;Describes a field in the datasource that can be used to create queries.&quot;,
 &quot;properties&quot;: {
  &quot;fieldName&quot;: {
  &quot;type&quot;: &quot;string&quot;
  },
  &quot;fieldCaption&quot;: {
  &quot;type&quot;: &quot;string&quot;
  },
  &quot;dataType&quot;: {
  &quot;type&quot;: &quot;string&quot;,
  &quot;enum&quot;: [
   &quot;INTEGER&quot;,
   &quot;REAL&quot;,
   &quot;STRING&quot;,
   &quot;DATETIME&quot;,
   &quot;BOOLEAN&quot;,
   &quot;DATE&quot;,
   &quot;SPATIAL&quot;,
   &quot;UNKNOWN&quot;
  ]
  },
  &quot;logicalTableId&quot;: {
  &quot;type&quot;: &quot;string&quot;
  }
 }
 },
 &quot;Filter&quot;: {
 &quot;type&quot;: &quot;object&quot;,
 &quot;description&quot;: &quot;A Filter to be used in the Query to filter on the datasource&quot;,
 &quot;required&quot;: [&quot;field&quot;, &quot;filterType&quot;],
 &quot;properties&quot;: {
  &quot;field&quot;: {
  &quot;$ref&quot;: &quot;#/components/schemas/FilterField&quot;
  },
  &quot;filterType&quot;: {
  &quot;type&quot;: &quot;string&quot;,
  &quot;enum&quot;: [
   &quot;QUANTITATIVE_DATE&quot;,
   &quot;QUANTITATIVE_NUMERICAL&quot;,
   &quot;SET&quot;,
   &quot;MATCH&quot;,
   &quot;DATE&quot;,
   &quot;TOP&quot;
  ]
  },
  &quot;context&quot;: {
  &quot;type&quot;: &quot;boolean&quot;,
  &quot;description&quot;: &quot;Make the given filter a Context Filter, meaning that it&apos;s an independent filter. Any other filters that you set are defined as dependent filters because they process only the data that passes through the context filter&quot;,
  &quot;default&quot;: false
  }
 },
 &quot;discriminator&quot;: {
  &quot;propertyName&quot;: &quot;filterType&quot;,
  &quot;mapping&quot;: {
  &quot;QUANTITATIVE_DATE&quot;: &quot;#/components/schemas/QuantitativeDateFilter&quot;,
  &quot;QUANTITATIVE_NUMERICAL&quot;: &quot;#/components/schemas/QuantitativeNumericalFilter&quot;,
  &quot;SET&quot;: &quot;#/components/schemas/SetFilter&quot;,
  &quot;MATCH&quot;: &quot;#/components/schemas/MatchFilter&quot;,
  &quot;DATE&quot;: &quot;#/components/schemas/RelativeDateFilter&quot;,
  &quot;TOP&quot;: &quot;#/components/schemas/TopNFilter&quot;
  }
 }
 },
 &quot;FilterField&quot;: {
 &quot;oneOf&quot;: [
  {
  &quot;required&quot;: [&quot;fieldCaption&quot;],
  &quot;additionalProperties&quot;: false,
  &quot;properties&quot;: {
   &quot;fieldCaption&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;The fieldCaption of the field to filter on. Do not use the fieldName, use the fieldCaption instead.&quot;
   }
  }
  },
  {
  &quot;required&quot;: [&quot;fieldCaption&quot;, &quot;function&quot;],
  &quot;additionalProperties&quot;: false,
  &quot;properties&quot;: {
   &quot;fieldCaption&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;The caption of the field to filter on&quot;
   },
   &quot;function&quot;: {
   &quot;$ref&quot;: &quot;#/components/schemas/Function&quot;
   }
  }
  },
  {
  &quot;required&quot;: [&quot;calculation&quot;],
  &quot;additionalProperties&quot;: false,
  &quot;properties&quot;: {
   &quot;calculation&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;A Tableau calculation which will be used to Filter on&quot;
   }
  }
  }
 ]
 },
 &quot;Function&quot;: {
 &quot;type&quot;: &quot;string&quot;,
 &quot;description&quot;: &quot;The standard set of Tableau aggregations which can be applied to a Field&quot;,
 &quot;enum&quot;: [
  &quot;SUM&quot;,
  &quot;AVG&quot;,
  &quot;MEDIAN&quot;,
  &quot;COUNT&quot;,
  &quot;COUNTD&quot;,
  &quot;MIN&quot;,
  &quot;MAX&quot;,
  &quot;STDEV&quot;,
  &quot;VAR&quot;,
  &quot;COLLECT&quot;,
  &quot;YEAR&quot;,
  &quot;QUARTER&quot;,
  &quot;MONTH&quot;,
  &quot;WEEK&quot;,
  &quot;DAY&quot;,
  &quot;TRUNC_YEAR&quot;,
  &quot;TRUNC_QUARTER&quot;,
  &quot;TRUNC_MONTH&quot;,
  &quot;TRUNC_WEEK&quot;,
  &quot;TRUNC_DAY&quot;
 ]
 },
 &quot;MatchFilter&quot;: {
 &quot;allOf&quot;: [
  {
  &quot;$ref&quot;: &quot;#/components/schemas/Filter&quot;
  },
  {
  &quot;type&quot;: &quot;object&quot;,
  &quot;description&quot;: &quot;A Filter that can be used to match against String Fields&quot;,
  &quot;properties&quot;: {
   &quot;contains&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;Matches when a Field contains this value&quot;
   },
   &quot;startsWith&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;Matches when a Field starts with this value&quot;
   },
   &quot;endsWith&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;Matches when a Field ends with this value&quot;
   },
   &quot;exclude&quot;: {
   &quot;type&quot;: &quot;boolean&quot;,
   &quot;description&quot;: &quot;When true, the inverse of the matching logic will be used&quot;,
   &quot;default&quot;: false
   }
  }
  }
 ]
 },
 &quot;QuantitativeFilterBase&quot;: {
 &quot;allOf&quot;: [
  {
  &quot;$ref&quot;: &quot;#/components/schemas/Filter&quot;
  },
  {
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [&quot;quantitativeFilterType&quot;],
  &quot;properties&quot;: {
   &quot;quantitativeFilterType&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;enum&quot;: [ &quot;RANGE&quot;, &quot;MIN&quot;, &quot;MAX&quot;, &quot;ONLY_NULL&quot;, &quot;ONLY_NON_NULL&quot; ]
   },
   &quot;includeNulls&quot;: {
   &quot;type&quot;: &quot;boolean&quot;,
   &quot;description&quot;: &quot;Only applies to RANGE, MIN, and MAX Filters. Should nulls be returned or not. If not provided the default is to not include null values&quot;
   }
  }
  }
 ]
 },
 &quot;QuantitativeNumericalFilter&quot;: {
 &quot;allOf&quot;: [
  {
  &quot;$ref&quot;: &quot;#/components/schemas/QuantitativeFilterBase&quot;
  }
 ],
 &quot;type&quot;: &quot;object&quot;,
 &quot;description&quot;: &quot;A Filter that can be used to find the minimumn, maximumn or range of numerical values of a Field&quot;,
 &quot;properties&quot;: {
  &quot;min&quot;: {
  &quot;type&quot;: &quot;number&quot;,
  &quot;description&quot;: &quot;A numerical value, either integer or floating point indicating the minimum value to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN&quot;
  },
  &quot;max&quot;: {
  &quot;type&quot;: &quot;number&quot;,
  &quot;description&quot;: &quot;A numerical value, either integer or floating point indicating the maximum value to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN&quot;
  }
 }
 },
 &quot;QuantitativeDateFilter&quot;: {
 &quot;allOf&quot;: [
  {
  &quot;$ref&quot;: &quot;#/components/schemas/QuantitativeFilterBase&quot;
  }
 ],
 &quot;type&quot;: &quot;object&quot;,
 &quot;description&quot;: &quot;A Filter that can be used to find the minimum, maximum or range of date values of a Field&quot;,
 &quot;properties&quot;: {
  &quot;minDate&quot;: {
  &quot;type&quot;: &quot;string&quot;,
  &quot;format&quot;: &quot;date&quot;,
  &quot;description&quot;: &quot;An RFC 3339 date indicating the earliest date to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN&quot;
  },
  &quot;maxDate&quot;: {
  &quot;type&quot;: &quot;string&quot;,
  &quot;format&quot;: &quot;date&quot;,
  &quot;description&quot;: &quot;An RFC 3339 date indicating the latest date to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN&quot;
  }
 }
 },
 &quot;Query&quot;: {
 &quot;description&quot;: &quot;The Query is the fundamental interface to Headless BI. It holds the specific semantics to perform against the Data Source. A Query consists of an array of Fields to query against, and an optional array of filters to apply to the query&quot;,
 &quot;required&quot;: [
  &quot;fields&quot;
 ],
 &quot;type&quot;: &quot;object&quot;,
 &quot;properties&quot;: {
  &quot;fields&quot;: {
  &quot;description&quot;: &quot;An array of Fields that define the query&quot;,
  &quot;type&quot;: &quot;array&quot;,
  &quot;items&quot;: {
   &quot;$ref&quot;: &quot;#/components/schemas/Field&quot;
  }
  },
  &quot;filters&quot;: {
  &quot;description&quot;: &quot;An optional array of Filters to apply to the query&quot;,
  &quot;type&quot;: &quot;array&quot;,
  &quot;items&quot;: {
   &quot;$ref&quot;: &quot;#/components/schemas/Filter&quot;
  }
  }
 },
 &quot;additionalProperties&quot;: false
 },
 &quot;SetFilter&quot;: {
 &quot;allOf&quot;: [
  {
  &quot;$ref&quot;: &quot;#/components/schemas/Filter&quot;
  }
 ],
 &quot;type&quot;: &quot;object&quot;,
 &quot;description&quot;: &quot;A Filter that can be used to filter on a specific set of values of a Field&quot;,
 &quot;required&quot;: [
  &quot;values&quot;
 ],
 &quot;properties&quot;: {
  &quot;values&quot;: {
  &quot;type&quot;: &quot;array&quot;,
  &quot;items&quot;: {},
  &quot;description&quot;: &quot;An array of values to filter on&quot;
  },
  &quot;exclude&quot;: {
  &quot;type&quot;: &quot;boolean&quot;,
  &quot;default&quot;: false
  }
 }
 },
 &quot;SortDirection&quot;: {
 &quot;type&quot;: &quot;string&quot;,
 &quot;description&quot;: &quot;The direction of the sort, either ascending or descending. If not supplied the default is ascending&quot;,
 &quot;enum&quot;: [
  &quot;ASC&quot;,
  &quot;DESC&quot;
 ]
 },
 &quot;RelativeDateFilter&quot;: {
 &quot;allOf&quot;: [
  {
  &quot;$ref&quot;: &quot;#/components/schemas/Filter&quot;
  },
  {
  &quot;type&quot;: &quot;object&quot;,
  &quot;description&quot;: &quot;A Filter that can be used to filter on dates using a specific anchor and fields that specify a relative date range to that anchor&quot;,
  &quot;required&quot;: [&quot;periodType&quot;, &quot;dateRangeType&quot;],
  &quot;properties&quot;: {
   &quot;periodType&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;The units of time in the relative date range&quot;,
   &quot;enum&quot;: [
    &quot;MINUTES&quot;,
    &quot;HOURS&quot;,
    &quot;DAYS&quot;,
    &quot;WEEKS&quot;,
    &quot;MONTHS&quot;,
    &quot;QUARTERS&quot;,
    &quot;YEARS&quot;
   ]
   },
   &quot;dateRangeType&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;description&quot;: &quot;The direction in the relative date range&quot;,
   &quot;enum&quot;: [
    &quot;CURRENT&quot;,
    &quot;LAST&quot;,
    &quot;LASTN&quot;,
    &quot;NEXT&quot;,
    &quot;NEXTN&quot;,
    &quot;TODATE&quot;
   ]
   },
   &quot;rangeN&quot;: {
   &quot;type&quot;: &quot;integer&quot;,
   &quot;description&quot;: &quot;When dateRangeType is LASTN or NEXTN, this is the N value (how many years, months, etc.).&quot;
   },
   &quot;anchorDate&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;format&quot;: &quot;date&quot;,
   &quot;description&quot;: &quot;When this field is not provided, defaults to today.&quot;
   },
   &quot;includeNulls&quot;: {
   &quot;type&quot;: &quot;boolean&quot;,
   &quot;description&quot;: &quot;Should nulls be returned or not. If not provided the default is to not include null values&quot;
   }
  }
  }
 ]
 },
 &quot;TopNFilter&quot;: {
 &quot;allOf&quot;: [
  {
  &quot;$ref&quot;: &quot;#/components/schemas/Filter&quot;
  },
  {
  &quot;type&quot;: &quot;object&quot;,
  &quot;description&quot;: &quot;A Filter that can be used to find the top or bottom number of Fields relative to the values in the fieldToMeasure&quot;,
  &quot;required&quot;: [&quot;howMany, fieldToMeasure&quot;],
  &quot;properties&quot;: {
   &quot;direction&quot;: {
   &quot;type&quot;: &quot;string&quot;,
   &quot;enum&quot;: [
    &quot;TOP&quot;,
    &quot;BOTTOM&quot;
    ],
   &quot;default&quot;: &quot;TOP&quot;,
   &quot;description&quot;: &quot;Top (Ascending) or Bottom (Descending) N&quot;
   },
   &quot;howMany&quot;: {
   &quot;type&quot;: &quot;integer&quot;,
   &quot;description&quot;: &quot;The number of values from the Top or the Bottom of the given fieldToMeasure&quot;
   },
   &quot;fieldToMeasure&quot;: {
   &quot;$ref&quot;: &quot;#/components/schemas/FilterField&quot;
   }
  }
  }
 ]
 }
}


###EXAMPLES
[
  {
    &quot;example&quot;: &quot;a simple query&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Category&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying a set filter&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
          },
          &quot;filterType&quot;: &quot;SET&quot;,
          &quot;values&quot;: [
            &quot;First Class&quot;,
            &quot;Standard Class&quot;
          ],
          &quot;exclude&quot;: &quot;false&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying a quantitative filter&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Sales&quot;,
            &quot;function&quot;: &quot;SUM&quot;
          },
          &quot;filterType&quot;: &quot;QUANTITATIVE_NUMERICAL&quot;,
          &quot;quantitativeFilterType&quot;: &quot;RANGE&quot;,
          &quot;min&quot;: 266839,
          &quot;max&quot;: 1149562
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying a quantitative date filter&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Order Date&quot;,
          &quot;function&quot;: &quot;YEAR&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Order Date&quot;,
          &quot;function&quot;: &quot;QUARTER&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Order Date&quot;
          },
          &quot;filterType&quot;: &quot;QUANTITATIVE_DATE&quot;,
          &quot;quantitativeFilterType&quot;: &quot;MIN&quot;,
          &quot;minDate&quot;: &quot;2020-01-01&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying a date filter&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Order Date&quot;,
          &quot;function&quot;: &quot;YEAR&quot;,
          &quot;sortPriority&quot;: 1
        },
        {
          &quot;fieldCaption&quot;: &quot;Order Date&quot;,
          &quot;function&quot;: &quot;MONTH&quot;,
          &quot;sortPriority&quot;: 2
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;filterType&quot;: &quot;DATE&quot;,
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Order Date&quot;
          },
          &quot;periodType&quot;: &quot;MONTHS&quot;,
          &quot;dateRangeType&quot;: &quot;CURRENT&quot;,
          &quot;anchorDate&quot;: &quot;2021-01-01&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying a match filter&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;State/Province&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;State/Province&quot;
          },
          &quot;filterType&quot;: &quot;MATCH&quot;,
          &quot;startsWith&quot;: &quot;A&quot;,
          &quot;endsWith&quot;: &quot;a&quot;,
          &quot;contains&quot;: &quot;o&quot;,
          &quot;exclude&quot;: &quot;false&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying a top N filter&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;State/Province&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Profit&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;State/Province&quot;
          },
          &quot;filterType&quot;: &quot;TOP&quot;,
          &quot;howMany&quot;: 10,
          &quot;fieldToMeasure&quot;: {
            &quot;fieldCaption&quot;: &quot;Profit&quot;,
            &quot;function&quot;: &quot;SUM&quot;
          },
          &quot;direction&quot;: &quot;TOP&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying a multi-set filter&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Segment&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
          },
          &quot;filterType&quot;: &quot;SET&quot;,
          &quot;values&quot;: [
            &quot;First Class&quot;,
            &quot;Standard Class&quot;
          ],
          &quot;exclude&quot;: &quot;false&quot;
        },
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Segment&quot;
          },
          &quot;filterType&quot;: &quot;SET&quot;,
          &quot;values&quot;: [
            &quot;Consumer&quot;
          ],
          &quot;exclude&quot;: &quot;true&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying multiple quantitative filters&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Profit&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Sales&quot;,
            &quot;function&quot;: &quot;SUM&quot;
          },
          &quot;filterType&quot;: &quot;QUANTITATIVE_NUMERICAL&quot;,
          &quot;quantitativeFilterType&quot;: &quot;MIN&quot;,
          &quot;min&quot;: 266839
        },
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Profit&quot;,
            &quot;function&quot;: &quot;SUM&quot;
          },
          &quot;filterType&quot;: &quot;QUANTITATIVE_NUMERICAL&quot;,
          &quot;quantitativeFilterType&quot;: &quot;MAX&quot;,
          &quot;max&quot;: 164098
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying set and quantitative filters&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
          },
          &quot;filterType&quot;: &quot;SET&quot;,
          &quot;values&quot;: [
            &quot;First Class&quot;,
            &quot;Standard Class&quot;
          ],
          &quot;exclude&quot;: &quot;true&quot;
        },
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Sales&quot;,
            &quot;function&quot;: &quot;SUM&quot;
          },
          &quot;filterType&quot;: &quot;QUANTITATIVE_NUMERICAL&quot;,
          &quot;quantitativeFilterType&quot;: &quot;MIN&quot;,
          &quot;min&quot;: 400000
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying a context filter&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Sub-Category&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Sub-Category&quot;
          },
          &quot;filterType&quot;: &quot;TOP&quot;,
          &quot;howMany&quot;: 10,
          &quot;fieldToMeasure&quot;: {
            &quot;fieldCaption&quot;: &quot;Sales&quot;,
            &quot;function&quot;: &quot;SUM&quot;
          },
          &quot;direction&quot;: &quot;TOP&quot;
        },
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Category&quot;
          },
          &quot;filterType&quot;: &quot;SET&quot;,
          &quot;values&quot;: [
            &quot;Furniture&quot;
          ],
          &quot;exclude&quot;: &quot;false&quot;,
          &quot;context&quot;: &quot;true&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;applying date, set and quantitative filters&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Order Date&quot;,
          &quot;function&quot;: &quot;TRUNC_DAY&quot;,
          &quot;sortPriority&quot;: 1,
          &quot;sortDirection&quot;: &quot;ASC&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Sales&quot;,
            &quot;function&quot;: &quot;SUM&quot;
          },
          &quot;filterType&quot;: &quot;QUANTITATIVE_NUMERICAL&quot;,
          &quot;quantitativeFilterType&quot;: &quot;RANGE&quot;,
          &quot;min&quot;: 10,
          &quot;max&quot;: 63
        },
        {
          &quot;filterType&quot;: &quot;DATE&quot;,
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Order Date&quot;
          },
          &quot;periodType&quot;: &quot;MONTHS&quot;,
          &quot;dateRangeType&quot;: &quot;NEXTN&quot;,
          &quot;rangeN&quot;: 3,
          &quot;anchorDate&quot;: &quot;2021-01-01&quot;
        },
        {
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Ship Mode&quot;
          },
          &quot;filterType&quot;: &quot;SET&quot;,
          &quot;values&quot;: [
            &quot;First Class&quot;
          ],
          &quot;exclude&quot;: &quot;false&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;Filtering data to a specific date using DATE filter, dates shown with TRUNC_DAY for day level accuracy, anchorDate is optional and if left empty defaults to today&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Order Date&quot;,
          &quot;function&quot;: &quot;TRUNC_DAY&quot;,
          &quot;sortPriority&quot;: 1,
          &quot;sortDirection&quot;: &quot;ASC&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;filterType&quot;: &quot;DATE&quot;,
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Date&quot;
          },
          &quot;periodType&quot;: &quot;DAYS&quot;,
          &quot;dateRangeType&quot;: &quot;CURRENT&quot;,
          &quot;anchorDate&quot;: &quot;2021-01-01&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;Relative DATE filter to handle questions about last 2 weeks where rangeN is used, anchorDate is optional and if left empty defaults to today&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Orders&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Order Date&quot;,
          &quot;function&quot;: &quot;TRUNC_DAY&quot;,
          &quot;sortPriority&quot;: 1,
          &quot;sortDirection&quot;: &quot;ASC&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;filterType&quot;: &quot;DATE&quot;,
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Order Date&quot;
          },
          &quot;periodType&quot;: &quot;WEEKS&quot;,
          &quot;dateRangeType&quot;: &quot;LASTN&quot;,
          &quot;rangeN&quot;: 2,
          &quot;anchorDate&quot;: &quot;2025-02-22&quot;
        }
      ]
    }
  },
  {
    &quot;example&quot;: &quot;Relative DATE filter to handle questions about last week, rangeN is not used here, anchorDate is optional and if left empty defaults to today&quot;,
    &quot;query&quot;: {
      &quot;fields&quot;: [
        {
          &quot;fieldCaption&quot;: &quot;Sales&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Orders&quot;,
          &quot;function&quot;: &quot;SUM&quot;
        },
        {
          &quot;fieldCaption&quot;: &quot;Order Date&quot;,
          &quot;function&quot;: &quot;TRUNC_DAY&quot;,
          &quot;sortPriority&quot;: 1,
          &quot;sortDirection&quot;: &quot;ASC&quot;
        }
      ],
      &quot;filters&quot;: [
        {
          &quot;filterType&quot;: &quot;DATE&quot;,
          &quot;field&quot;: {
            &quot;fieldCaption&quot;: &quot;Order Date&quot;
          },
          &quot;periodType&quot;: &quot;WEEKS&quot;,
          &quot;dateRangeType&quot;: &quot;LAST&quot;
        }
      ]
    }
  }
]


###QUERY
{!$Input:User_Query}

###DATA_MODEL
{!$Apex:TableauVDSReadMetadata.Prompt}

</content>
        <inputs>
            <apiName>User_Query</apiName>
            <definition>primitive://String</definition>
            <masterLabel>User_Query</masterLabel>
            <referenceName>Input:User_Query</referenceName>
            <required>true</required>
        </inputs>
        <primaryModel>sfdc_ai__DefaultOpenAIGPT4OmniMini</primaryModel>
        <status>Published</status>
        <templateDataProviders>
            <definition>apex://TableauVDSReadMetadata</definition>
            <parameters>
                <definition>primitive://String</definition>
                <isRequired>true</isRequired>
                <parameterName>User_Query</parameterName>
                <valueExpression>{!$Input:User_Query}</valueExpression>
            </parameters>
            <referenceName>Apex:TableauVDSReadMetadata</referenceName>
        </templateDataProviders>
        <versionIdentifier>9vM4kARA/dVBp9lU652os39QuKCF9SJIH4kC0V6ulcM=_3</versionIdentifier>
    </templateVersions>
    <type>einstein_gpt__flex</type>
    <visibility>Global</visibility>
</GenAiPromptTemplate>
